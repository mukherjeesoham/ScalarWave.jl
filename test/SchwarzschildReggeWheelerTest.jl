#--------------------------------------------------------------------
# Spacetime Discretization methods in Julia
# Soham 04-2018
# Wave equation on Schwarzschild; compare with Regge-Wheeler
#--------------------------------------------------------------------

using Einsum

#--------------------------------------------------------------------
# Set grid size and initial data 
#--------------------------------------------------------------------
M          = 1.0
𝒍          = 0
ω          = 0.1
P1, P2     = 20, 20
Umin, Umax = -3M, -7M
Vmin, Vmax =  3M,  7M

SUV = ProductSpace{GaussLobatto{U,P1}, GaussLobatto{V,P2}}

#--------------------------------------------------------------------
# Define derivative and boundary operators
#--------------------------------------------------------------------
𝔹 = boundary(Null, SUV)

#--------------------------------------------------------------------
# Define coordinates and their associated derivatives
#--------------------------------------------------------------------
𝕌 = Field(SUV, (U,V)->U)
𝕍 = Field(SUV, (U,V)->V)
θ = Field(SUV, (𝑼,𝑽)->pi/2)
ϕ = Field(SUV, (𝑼,𝑽)->0)
ø = zero(SUV) 
Ø = zero(Null, SUV) 

𝑼 = (Umax + Umin)/2 + (Umax - Umin)/2*𝕌  
𝑽 = (Vmax + Vmin)/2 - (Vmax - Vmin)/2*𝕍  

t = Field(SUV, (𝑼,𝑽)->find_t_of_UV(𝑼, 𝑽, M), 𝑼, 𝑽)
r = Field(SUV, (𝑼,𝑽)->find_r_of_UV(𝑼, 𝑽, M), 𝑼, 𝑽)

drawpatch(𝑼, "../output/U")
drawpatch(𝑽, "../output/V")
drawpatch(t, "../output/t_of_UV")
drawpatch(r, "../output/r_of_UV")

𝔻𝑼, 𝔻𝑽 = derivativetransform(SUV, 𝑼, 𝑽) 
𝔻θ, 𝔻ϕ = Ø, Ø

#--------------------------------------------------------------------
# Set boundary conditions [Use Regge Wheeler Initial Data]
#--------------------------------------------------------------------

# [1] Computing initial data with ApproxFun code
import Scattering.radialsolve
import ApproxFun.evaluate

rmin, rmax = minimum(r), maximum(r) 
@show rmin
@show rmax

# Boundary conditions for radial solver from Mathematica notebook
ϕ_at_rmin = 1.7907673567951274
ϕ_at_rmax = 2.3370573622442246

function phi_in_UV(t, r, ϕ, ω)
    @assert r >= ϕ.space.domain.a && r <= ϕ.space.domain.b
    return evaluate(ϕ, r)*cos(-ω*t)
end

ϕ = radialsolve(M, ω, 𝒍, rmin, rmax, ϕ_at_rmin, ϕ_at_rmax).u
𝕤 = Field(SUV, (t,r)->phi_in_UV(t, r, ϕ, ω), t, r) 
𝕓 = 𝔹*𝕤

#----------------------------------------------------------------------
# Compute the boundary conditions directly from the Mathematica notebook
# A hack, but the only option left.
#----------------------------------------------------------------------

r_l = r.value[:, 1]
t_l = t.value[:, 1]

r_r = r.value[1, :]
t_r = t.value[1, :]

#@show r_l
#@show r_r

# Output copied from Mathematica
ϕrl = [2.06704, 2.06589, 2.06243, 2.05668, 2.04865, 2.03839, 2.02595,
      2.0114, 1.99487, 1.97653, 1.95661, 1.93542, 1.91339, 1.89103, 
      1.86902, 1.84812, 1.82922, 1.81322, 1.80103, 1.79338, 1.79077]
ϕrr = [2.06704, 2.06972, 2.07755, 2.08998, 2.10621, 2.12526, 2.14617, 
      2.16804, 2.19007, 2.21162, 2.23219, 2.25139, 2.26896, 2.2847, 
      2.29848, 2.31022, 2.31986, 2.32738, 2.33275, 2.33598, 2.33706]

ϕl = ϕrl.*cos.(ω.*t_l)
ϕr = ϕrr.*cos.(ω.*t_r)

b = zeros(21, 21)
b[:, 1] = ϕl
b[1, :] = ϕr

𝕓 = Boundary(SUV, b)
ρ = 0 

#--------------------------------------------------------------------
# Define metric functions 
# Tests ----------------
#       [1] Christoffel Symbols / Mathematica [done]
#       [2] Ricci Tensor upto a constant / Mathematica [done]
#       [3] Eigen value plots -> not so useful for our case [done]
#--------------------------------------------------------------------

𝒈𝑼𝑽 = -32*(M^3/r)*(exp(-r/2M))
𝒈θθ = r^2
𝒈ϕϕ = (r*sin(θ))^2

𝒈𝑼𝑼 = 𝒈𝑽𝑽 = ø
𝒈𝑼θ = 𝒈𝑼ϕ = ø
𝒈𝑽θ = 𝒈𝑽ϕ = ø
𝒈θϕ = ø

𝕘    = Metric{dd, 4}([𝒈𝑼𝑼, 𝒈𝑼𝑽, 𝒈𝑼θ, 𝒈𝑼ϕ, 
                           𝒈𝑽𝑽, 𝒈𝑽θ, 𝒈𝑽ϕ,
                                𝒈θθ, 𝒈θϕ,
                                     𝒈ϕϕ])

𝕘inv = inv(𝕘) 
𝔻    = Derivative{u, 4}([𝔻𝑼, 𝔻𝑽, 𝔻θ, 𝔻ϕ])
Γ    = Christoffel(𝕘)
@einsum Γ[m, i, j] = (1/2)*𝕘inv[m,k]*(𝔻[j]*𝕘[k,i]+  𝔻[i]*𝕘[k,j] - 𝔻[k]*𝕘[i,j])
println("Finished computing auxilliary quantities. Computing the operator")

#--------------------------------------------------------------------
# Now construct the operator [Testing in Progress] 
# Tests ------------------------------------------
#       [1] Compute the residual with the solution generated by ApproxFun [done]
#       [2] Compare ApproxFun solution with Cardoso et al. solution [done; doesn't agree]
#       [3] Compare two different definitions of operators
#       [4] Compare solution with Cardoso et. al. [done, in part] 

#--------------------------------------------------------------------
𝕃1 = ( sum(𝕘inv[j,k]*𝔻[j]*𝔻[k] for j in 1:dim(𝕘), k in 1:dim(𝕘))  
     - sum(𝕘inv[j,k]*Γ[l,j,k]*𝔻[l] for j in 1:dim(𝕘), k in 1:dim(𝕘), l in 1:dim(𝕘)) ) 

#--------------------------------------------------------------------
# Solve the system [also check the condition number and eigen values]
#--------------------------------------------------------------------
𝕨 = solve(𝕃1 + 𝔹, ρ + 𝕓) 
println("Finished solve. Generating plots.")

# Check if the solution matches the Mathematica code with initial 
# conditions from ApproxFun
@show r.value[10, 10]
@show 𝕨.value[10, 10]

# Compute the operator on the solution from ApproxFun
𝕤res = 𝕃1*𝕤

drawpatch(𝕨,    "../output/schwarzschild-field")
drawpatch(𝕤,    "../output/solution-field")
drawpatch(𝕤res, "../output/solution-res-field")
drawpatch(𝕨-𝕤,  "../output/error-schwarzschild")

@show maximum(abs(𝕨-𝕤))
@show maximum(abs(𝕤res))

